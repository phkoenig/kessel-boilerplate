"use client"

import { useState, useEffect } from "react"
import { Image, RefreshCw, Check, Loader2 } from "lucide-react"
import { Label } from "@/components/ui/label"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Textarea } from "@/components/ui/textarea"
import { Button } from "@/components/ui/button"
import { Switch } from "@/components/ui/switch"
import { Slider } from "@/components/ui/slider"
import { AppIcon } from "@/components/ui/app-icon"
import { MonochromeIcon } from "@/components/ui/monochrome-icon"
import { InlineEditInput } from "@/components/ui/inline-edit-input"
import { createClient } from "@/utils/supabase/client"
import { cn } from "@/lib/utils"

/**
 * AppIconGenerator Komponente
 *
 * UI analog zur Profil-Seite:
 * - Links: Icon-Vorschau mit Varianten
 * - Rechts: Formularfelder + Generator-Controls
 */
export function AppIconGenerator(): React.ReactElement {
  const supabase = createClient()

  // Form States
  const [appName, setAppName] = useState("")
  const [description, setDescription] = useState("")
  const [prompt, setPrompt] = useState("")
  const [variants, setVariants] = useState(4) // Standard: 4 Varianten
  const [provider, setProvider] = useState<"openrouter" | "fal">("openrouter")
  const [model, setModel] = useState<string>("nano-banana-pro") // Standard: Nano Banana Pro
  const [isGeneratingPrompt, setIsGeneratingPrompt] = useState(false)

  // Icon States
  const [currentIconUrl, setCurrentIconUrl] = useState<string | null>(null)
  const [_iconVariants, setIconVariants] = useState<Array<{ url: string }>>([])
  const [selectedVariantIndex, setSelectedVariantIndex] = useState(0)

  // Generation States
  const [isGenerating, setIsGenerating] = useState(false)
  const [generatedVariants, setGeneratedVariants] = useState<
    Array<{ url: string; base64?: string }>
  >([])
  const [isSaving, setIsSaving] = useState(false)
  const [saved, setSaved] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Kosteninformationen
  const [generationCost, setGenerationCost] = useState<{
    totalCost: number
    costPerImage: number
    currency: string
    imageCount: number
  } | null>(null)

  // Available Providers mit Modellen
  const [availableProviders, setAvailableProviders] = useState<
    Array<{ id: string; name: string; models: string[]; defaultModel: string }>
  >([])

  // Default-Werte aus Kessel Boilerplate, die auf ENV-Variable fallen sollen
  const BOILERPLATE_DEFAULTS = ["Kessel App", "Test Demo 123", "Testdemo123"]

  // Lade app_settings beim Mount (via API für tenant_slug-Filterung)
  useEffect(() => {
    async function loadAppSettings() {
      try {
        const response = await fetch("/api/app-settings")
        if (!response.ok) {
          console.error("Error loading app settings:", response.statusText)
          return
        }
        const data = await response.json()

        if (data.error) {
          console.error("Error loading app settings:", data.error)
          return
        }

        if (data) {
          console.log("[AppIconGenerator] Loaded app settings:", data)
          console.log("[AppIconGenerator] Icon URL:", data.icon_url)

          // App-Name Priorität:
          // 1. DB-Wert wenn vom User geändert (nicht Default)
          // 2. ENV-Variable als Fallback für Defaults
          // 3. "App" als letzter Fallback
          const dbAppName = data.app_name || ""
          const envAppName = process.env.NEXT_PUBLIC_APP_NAME || ""
          const isDbDefault = BOILERPLATE_DEFAULTS.some(
            (d) => d.toLowerCase() === dbAppName.toLowerCase()
          )

          let finalAppName: string
          if (dbAppName && !isDbDefault) {
            // DB-Wert hat Priorität wenn vom User geändert
            finalAppName = dbAppName
          } else if (envAppName) {
            // ENV als Fallback wenn DB leer oder noch Default
            finalAppName = envAppName
          } else {
            // Letzter Fallback
            finalAppName = "App"
          }

          setAppName(finalAppName)
          setDescription(data.app_description || "")
          setCurrentIconUrl(data.icon_url)
          setIconVariants((data.icon_variants as Array<{ url: string }>) || [])
          const loadedProvider = (data.icon_provider as "openrouter" | "fal") || "openrouter"
          setProvider(loadedProvider)
          // Modell wird später durch useEffect gesetzt, wenn Provider geladen ist
        }
      } catch (err) {
        console.error("Error loading app settings:", err)
      }
    }

    loadAppSettings()
  }, [])

  // Automatische Prompt-Generierung beim ersten Laden wenn App-Name und Beschreibung vorhanden sind
  const [hasAutoGeneratedPrompt, setHasAutoGeneratedPrompt] = useState(false)
  useEffect(() => {
    if (
      appName.trim() &&
      description.trim() &&
      !prompt.trim() &&
      !isGeneratingPrompt &&
      !hasAutoGeneratedPrompt
    ) {
      setHasAutoGeneratedPrompt(true)
      handleGeneratePrompt()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [appName, description])

  // Lade verfügbare Provider
  useEffect(() => {
    async function loadProviders() {
      try {
        const response = await fetch("/api/media-providers")
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ error: "Unknown error" }))
          console.error("[AppIconGenerator] Error loading providers:", errorData)
          // Fallback: OpenRouter ist immer verfügbar
          setAvailableProviders([
            { id: "openrouter", name: "OpenRouter", models: ["flux-2"], defaultModel: "flux-2" },
          ])
          return
        }
        const data = await response.json()
        const providers = data.providers || []
        setAvailableProviders(providers)
      } catch (err) {
        console.error("[AppIconGenerator] Error loading providers:", err)
        // Fallback: OpenRouter ist immer verfügbar
        setAvailableProviders([
          { id: "openrouter", name: "OpenRouter", models: ["flux-2"], defaultModel: "flux-2" },
        ])
      }
    }

    loadProviders()
  }, [])

  // Aktualisiere das Modell wenn sich der Provider ändert oder Provider geladen wurden
  useEffect(() => {
    if (availableProviders.length === 0) return

    const currentProviderConfig = availableProviders.find((p) => p.id === provider)
    if (!currentProviderConfig) return

    // Prüfe ob das aktuelle Modell zum Provider passt
    const isModelValidForProvider = currentProviderConfig.models.includes(model)

    if (!model || !isModelValidForProvider) {
      console.log(
        `[AppIconGenerator] Updating model: ${model} -> ${currentProviderConfig.defaultModel} (provider: ${provider})`
      )
      setModel(currentProviderConfig.defaultModel)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [provider, availableProviders])

  // Einzelnes Feld speichern (App-Name oder Beschreibung) via API
  async function handleSaveField(field: "app_name" | "app_description", value: string) {
    try {
      const response = await fetch("/api/app-settings", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ [field]: value }),
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: "Unknown error" }))
        throw new Error(errorData.error || `HTTP ${response.status}`)
      }

      // State aktualisieren
      if (field === "app_name") {
        setAppName(value)
      } else {
        setDescription(value)
      }

      console.log(`[AppIconGenerator] Saved ${field}:`, value)
    } catch (err) {
      console.error(`[AppIconGenerator] Error saving ${field}:`, err)
      setError(
        `Fehler beim Speichern: ${err instanceof Error ? err.message : "Unbekannter Fehler"}`
      )
      throw err // Re-throw damit InlineEditInput im Edit-Modus bleibt
    }
  }

  // Prompt automatisch generieren
  async function handleGeneratePrompt() {
    if (!appName.trim() || !description.trim()) {
      setError("App-Name und Beschreibung sind erforderlich für Prompt-Generierung")
      return
    }

    setIsGeneratingPrompt(true)
    setError(null)

    try {
      const response = await fetch("/api/generate-icon-prompt", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          appName: appName.trim(),
          description: description.trim(),
        }),
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: "Unknown error" }))
        console.error("[AppIconGenerator] Prompt generation error:", errorData)
        throw new Error(
          errorData.error || errorData.message || `HTTP ${response.status}: ${response.statusText}`
        )
      }

      const data = await response.json()
      if (!data.prompt) {
        throw new Error("Kein Prompt in der Antwort erhalten")
      }
      setPrompt(data.prompt)
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Fehler bei der Prompt-Generierung"
      console.error("[AppIconGenerator] Error generating prompt:", err)
      setError(errorMessage)
    } finally {
      setIsGeneratingPrompt(false)
    }
  }

  // Icon generieren
  async function handleGenerate() {
    if (!appName.trim() || !description.trim()) {
      setError("App-Name und Beschreibung sind erforderlich")
      return
    }

    if (!prompt.trim()) {
      setError("Bitte generieren Sie zuerst einen Prompt oder geben Sie einen manuell ein")
      return
    }

    setIsGenerating(true)
    setError(null)
    setGeneratedVariants([])

    try {
      // DEBUG: Log was gesendet wird
      console.log(
        "[AppIconGenerator] Generating with: provider=" +
          provider +
          ", model=" +
          model +
          ", variants=" +
          variants
      )

      const response = await fetch("/api/generate-app-icon", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          appName: appName.trim(),
          description: description.trim(),
          prompt: prompt.trim(),
          variants,
          provider,
          model: model || undefined, // Verwende ausgewähltes Modell oder Provider-Default
        }),
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: "Unknown error" }))
        console.error("[AppIconGenerator] Icon generation error:", errorData)
        throw new Error(
          errorData.error || errorData.message || `HTTP ${response.status}: ${response.statusText}`
        )
      }

      const data = await response.json()
      if (!data.images || data.images.length === 0) {
        throw new Error("Keine Icons in der Antwort erhalten")
      }
      setGeneratedVariants(data.images || [])
      setSelectedVariantIndex(0)
      setCurrentIconUrl(data.images[0].url)

      // Kosten speichern (falls vorhanden)
      if (data.cost) {
        setGenerationCost(data.cost)
        console.log("[AppIconGenerator] Generation cost:", data.cost)
      } else {
        setGenerationCost(null)
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Fehler bei der Icon-Generierung"
      console.error("[AppIconGenerator] Error generating icon:", err)
      setError(errorMessage)
    } finally {
      setIsGenerating(false)
    }
  }

  // Icon speichern
  async function handleSave() {
    if (generatedVariants.length === 0) {
      setError("Keine generierten Varianten zum Speichern")
      return
    }

    setIsSaving(true)
    setError(null)

    try {
      // Prüfe ob User eingeloggt ist
      const {
        data: { user },
        error: userError,
      } = await supabase.auth.getUser()

      if (userError || !user) {
        throw new Error("Nicht eingeloggt. Bitte melde dich an.")
      }

      console.log("[AppIconGenerator] User:", user.id)

      const selectedVariant = generatedVariants[selectedVariantIndex]
      if (!selectedVariant) {
        throw new Error("Keine Variante ausgewählt")
      }

      if (!selectedVariant.url) {
        throw new Error("Die ausgewählte Variante hat keine URL")
      }

      console.log("[AppIconGenerator] Saving icon:", {
        icon_url: selectedVariant.url,
        app_name: appName.trim(),
        icon_provider: provider,
        variants_count: generatedVariants.length,
      })

      const updateData = {
        app_name: appName.trim(),
        app_description: description.trim(),
        icon_url: selectedVariant.url,
        icon_variants: generatedVariants.map((img) => ({ url: img.url })),
        icon_provider: provider,
      }

      console.log("[AppIconGenerator] Update data:", updateData)

      // Via API speichern (für tenant_slug-Filterung)
      const response = await fetch("/api/app-settings", {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(updateData),
      })

      const responseData = await response.json()
      console.log("[AppIconGenerator] Update response:", { data: responseData, ok: response.ok })

      if (!response.ok) {
        console.error("[AppIconGenerator] Update error details:", responseData)

        // Spezifische Fehlermeldungen
        if (responseData.error?.includes("permission")) {
          throw new Error(
            "Keine Berechtigung zum Speichern. Bitte stelle sicher, dass du als Admin eingeloggt bist."
          )
        }

        throw new Error(`Fehler beim Speichern: ${responseData.error || "Unbekannter Fehler"}`)
      }

      console.log("[AppIconGenerator] Successfully saved:", responseData)

      setCurrentIconUrl(selectedVariant.url)
      setIconVariants(generatedVariants.map((img) => ({ url: img.url })))
      setSaved(true)

      // Kurz warten, damit der User die Erfolgsmeldung sieht,
      // dann Seite vollständig neu laden für korrektes Icon-Update überall
      setTimeout(() => {
        window.location.reload()
      }, 500)
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Fehler beim Speichern"
      console.error("[AppIconGenerator] Save error:", err)
      setError(errorMessage)
    } finally {
      setIsSaving(false)
    }
  }

  // Variante auswählen
  function handleSelectVariant(index: number) {
    setSelectedVariantIndex(index)
    if (generatedVariants[index]) {
      setCurrentIconUrl(generatedVariants[index].url)
    }
  }

  // Prüfe ob Änderungen vorhanden
  const hasChanges = generatedVariants.length > 0

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Image className="size-5" />
          App-Icon Generator
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="flex gap-8">
          {/* Links: Icon-Vorschau */}
          <div className="flex flex-col items-center gap-4">
            <div className="relative">
              {/* Icon-Vorschau: bg-muted als Hintergrund, text-foreground für Icon-Farbe */}
              <div className="bg-muted text-foreground flex size-32 items-center justify-center overflow-hidden rounded-lg border">
                {currentIconUrl ? (
                  <MonochromeIcon src={currentIconUrl} alt="App Icon" size={112} />
                ) : (
                  <AppIcon size={128} />
                )}
              </div>
              {hasChanges && (
                <div className="bg-warning absolute -top-1 -right-1 size-4 animate-pulse rounded-full" />
              )}
            </div>

            {/* Varianten-Grid */}
            {generatedVariants.length > 0 && (
              <div className="grid grid-cols-2 gap-2">
                {generatedVariants.map((variant, index) => (
                  <button
                    key={index}
                    onClick={() => handleSelectVariant(index)}
                    className={cn(
                      "bg-muted text-foreground hover:ring-ring flex size-16 items-center justify-center rounded-lg border transition-all hover:ring-2",
                      selectedVariantIndex === index && "ring-primary ring-2"
                    )}
                  >
                    <MonochromeIcon src={variant.url} alt={`Variante ${index + 1}`} size={48} />
                  </button>
                ))}
              </div>
            )}

            {/* Generieren-Button */}
            <div className="flex flex-col gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={handleGenerate}
                disabled={isGenerating || !appName.trim() || !description.trim() || !prompt.trim()}
                className="gap-2"
              >
                {isGenerating ? (
                  <Loader2 className="size-4 animate-spin" />
                ) : (
                  <RefreshCw className="size-4" />
                )}
                {isGenerating ? "Generiere..." : "Neu generieren"}
              </Button>

              {hasChanges && (
                <>
                  <Button
                    variant="default"
                    size="sm"
                    onClick={handleSave}
                    disabled={isSaving}
                    className="gap-2"
                  >
                    {isSaving ? (
                      <Loader2 className="size-4 animate-spin" />
                    ) : saved ? (
                      <Check className="size-4" />
                    ) : null}
                    Speichern
                  </Button>
                </>
              )}

              {/* Kostenanzeige */}
              {generationCost && (
                <div className="text-muted-foreground mt-2 text-xs">
                  <span className="font-medium">Kosten:</span>{" "}
                  {generationCost.totalCost < 0.01
                    ? `$${generationCost.totalCost.toFixed(6)}`
                    : `$${generationCost.totalCost.toFixed(4)}`}
                  {generationCost.imageCount > 1 && (
                    <span className="ml-1">
                      ({generationCost.imageCount} Bilder à $
                      {generationCost.costPerImage < 0.01
                        ? generationCost.costPerImage.toFixed(6)
                        : generationCost.costPerImage.toFixed(4)}
                      )
                    </span>
                  )}
                </div>
              )}
            </div>
          </div>

          {/* Rechts: Formularfelder */}
          <div className="flex-1 space-y-4">
            {error && (
              <div className="bg-destructive/10 text-destructive border-destructive/20 rounded-md border p-4 text-sm">
                {error}
              </div>
            )}

            <InlineEditInput
              id="appName"
              label="App-Name *"
              value={appName}
              onSave={(value) => handleSaveField("app_name", value)}
              onSaveSuccess={() => window.location.reload()}
              placeholder="z.B. Meine App"
              disabled={isGenerating}
            />

            <InlineEditInput
              id="description"
              label="Beschreibung *"
              value={description}
              onSave={(value) => handleSaveField("app_description", value)}
              onSaveSuccess={() => window.location.reload()}
              placeholder="z.B. Boilerplate für B2B-Apps"
              disabled={isGenerating}
            />

            <div>
              <div className="mb-2 flex items-center justify-between">
                <Label htmlFor="prompt">Icon-Prompt *</Label>
                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={handleGeneratePrompt}
                  disabled={isGeneratingPrompt || !appName.trim() || !description.trim()}
                  className="h-7 text-xs"
                >
                  {isGeneratingPrompt ? (
                    <>
                      <Loader2 className="mr-1 size-3 animate-spin" />
                      Generiere...
                    </>
                  ) : (
                    "KI-generieren"
                  )}
                </Button>
              </div>
              <Textarea
                id="prompt"
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
                placeholder="minimal monochrome app icon, flat, vector-like, no text, no background, for a..."
                disabled={isGenerating}
                rows={8}
                className="font-mono text-sm"
              />
              <p className="text-muted-foreground mt-1 text-xs">
                Der Prompt wird automatisch basierend auf App-Wiki generiert. Sie können ihn
                anpassen.
              </p>
            </div>

            <div>
              <Label htmlFor="variants">Varianten: {variants}</Label>
              <Slider
                id="variants"
                value={[variants]}
                onValueChange={(values) => setVariants(values[0] || 1)}
                min={1}
                max={4}
                step={1}
                disabled={isGenerating}
                className="mt-2"
              />
            </div>

            <div className="flex items-center justify-between rounded-lg border p-4">
              <div className="space-y-0.5">
                <Label htmlFor="provider-switch" className="text-sm font-medium">
                  Provider
                </Label>
                <p className="text-muted-foreground text-xs">
                  {provider === "openrouter" ? "OpenRouter" : "fal.ai"} ({model || "Standard"})
                </p>
              </div>
              <div className="flex items-center gap-2">
                <span
                  className={cn(
                    "text-xs",
                    provider === "openrouter"
                      ? "text-foreground font-medium"
                      : "text-muted-foreground"
                  )}
                >
                  OpenRouter
                </span>
                <Switch
                  id="provider-switch"
                  checked={provider === "fal"}
                  onCheckedChange={(checked) => {
                    const newProvider = checked ? "fal" : "openrouter"
                    setProvider(newProvider)
                    // Setze Standardmodell des neuen Providers
                    const providerConfig = availableProviders.find((p) => p.id === newProvider)
                    if (providerConfig) {
                      setModel(providerConfig.defaultModel)
                    }
                  }}
                  disabled={isGenerating || !availableProviders.some((p) => p.id === "fal")}
                />
                <span
                  className={cn(
                    "text-xs",
                    provider === "fal" ? "text-foreground font-medium" : "text-muted-foreground"
                  )}
                >
                  fal.ai
                </span>
              </div>
            </div>

            {/* Modellauswahl - Immer anzeigen wenn mehr als 1 Modell verfügbar */}
            {(() => {
              const currentProvider = availableProviders.find((p) => p.id === provider)
              if (!currentProvider || !currentProvider.models || currentProvider.models.length < 1)
                return null
              // Zeige Modellauswahl auch wenn nur 1 Modell vorhanden (für bessere UX)
              return (
                <div>
                  <Label htmlFor="model" className="text-sm font-medium">
                    Modell
                  </Label>
                  <select
                    id="model"
                    value={model}
                    onChange={(e) => {
                      console.log(`[AppIconGenerator] User selected model: ${e.target.value}`)
                      setModel(e.target.value)
                    }}
                    disabled={isGenerating}
                    className="border-input bg-background ring-offset-background placeholder:text-muted-foreground focus:ring-ring mt-2 flex h-10 w-full rounded-md border px-4 py-2 text-sm file:border-0 file:bg-transparent file:text-sm file:font-medium focus:ring-2 focus:ring-offset-2 focus:outline-none disabled:cursor-not-allowed disabled:opacity-50"
                  >
                    {currentProvider.models.map((m) => (
                      <option key={m} value={m}>
                        {m}
                      </option>
                    ))}
                  </select>
                </div>
              )
            })()}
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
