---
description: Secrets & Environment Management via Supabase Vault.
globs: ["**/.env*", "**/env.mjs", "**/pull-env.mjs", "**/vercel.json"]
alwaysApply: false
---

# Secrets & Environment

**WICHTIG:** NIEMALS Secrets manuell in `.env.local` schreiben! Immer via Vault.

## Architektur

```
┌─────────────────┐         ┌─────────────────┐
│   Supabase      │         │   .env.local    │
│   Vault         │ ──────▶ │   (generiert)   │
│   (Secret Store)│         │                 │
└─────────────────┘         └─────────────────┘
        ▲                           │
        │                           ▼
┌─────────────────┐         ┌─────────────────┐
│   .env          │         │   Next.js App   │
│   (Bootstrap)   │         │   (Runtime)     │
└─────────────────┘         └─────────────────┘
```

---

## Dateien

| Datei | Inhalt | Git |
|-------|--------|-----|
| `.env` | Bootstrap: Vault-URL + SERVICE_ROLE_KEY | ❌ ignoriert |
| `.env.local` | Alle Secrets (via `pnpm pull-env`) | ❌ ignoriert |

---

## Neues Secret hinzufügen (WICHTIG!)

**Schritt 1:** Secret im Vault speichern via REST API:

```bash
# Hole Service Role Key aus .env.local
SERVICE_KEY=$(grep SUPABASE_SERVICE_ROLE_KEY .env.local | cut -d= -f2)

# Füge Secret zum Vault hinzu
curl -X POST "https://ufqlocxqizmiaozkashi.supabase.co/rest/v1/rpc/insert_secret" \
  -H "apikey: $SERVICE_KEY" \
  -H "Authorization: Bearer $SERVICE_KEY" \
  -H "Content-Type: application/json" \
  -d '{"name": "MEIN_SECRET_NAME", "secret": "mein-secret-wert"}'
```

**Schritt 2:** Secret in `.env.local` laden:

```bash
pnpm pull-env
```

**Schritt 3:** Dev-Server neustarten (um neue Env-Vars zu laden)

---

## Standard-Workflow

```bash
# 1. Setup: .env mit Vault-Credentials
# (manuell oder via CLI)

# 2. Secrets abrufen
pnpm pull-env

# 3. Dev-Server starten
pnpm dev
```

---

## Environment Variables

### Client-seitig (`NEXT_PUBLIC_*`)
```bash
NEXT_PUBLIC_SUPABASE_URL=https://xxx.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJ...
NEXT_PUBLIC_APP_NAME=My App
```

### Server-seitig (NIEMALS `NEXT_PUBLIC_*`)
```bash
SUPABASE_SERVICE_ROLE_KEY=eyJ...
OPENROUTER_API_KEY=sk-or-...
```

### VERBOTEN: Fallback-Defaults im Code
```typescript
// ❌ NIEMALS
const apiKey = process.env.API_KEY || "dev-key-12345"
const url = process.env.URL || "http://localhost:3000"

// ✅ RICHTIG: Validierung wirft Fehler wenn fehlt
const apiKey = env.API_KEY // via @t3-oss/env-nextjs
```

---

## Validierung mit @t3-oss/env-nextjs

```typescript
// src/env.mjs
import { createEnv } from "@t3-oss/env-nextjs"
import { z } from "zod"

export const env = createEnv({
  server: {
    OPENROUTER_API_KEY: z.string().min(1),
  },
  client: {
    NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
    NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
  },
  runtimeEnv: {
    OPENROUTER_API_KEY: process.env.OPENROUTER_API_KEY,
    NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
    NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  },
})
```

---

## Vercel Deployment

```bash
# Prüfen
npx vercel env ls

# Setzen (für alle Environments)
echo "VALUE" | npx vercel env add VAR_NAME production
echo "VALUE" | npx vercel env add VAR_NAME preview
echo "VALUE" | npx vercel env add VAR_NAME development
```

### Wichtig:
- `NEXT_PUBLIC_*`: Als "Public" setzen
- Server-Secrets: Als "Private" setzen (nicht Public!)
- Für alle Environments setzen: Production, Preview, Development

---

## Regeln

1. **SERVICE_ROLE_KEY nur serverseitig** - Niemals `NEXT_PUBLIC_*`, niemals im Client-Code
2. **Alle Secrets im Supabase Vault** - Keine externe Plattform (Doppler, etc.)
3. **`pnpm pull-env` vor Dev-Start** - Bei Secret-Änderungen
4. **Niemals .env committen** - Immer in .gitignore
5. **Validierung mit @t3-oss/env-nextjs** - Fail-fast bei fehlenden Variablen
6. **Keine Fallback-Defaults für Secrets** - Kein `|| 'dev-key'` im Code
7. **CI/CD: Env-Validation als eigenen Schritt** - Build/Deploy failen lassen wenn Variablen fehlen
