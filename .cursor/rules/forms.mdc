---
description: React Hook Form + Zod Patterns für Formular-Handling.
globs: ["**/*.tsx", "**/components/ui/form.tsx"]
alwaysApply: false
---

# Forms: React Hook Form + Zod

Dieses Projekt verwendet React Hook Form mit Zod für typsichere Formular-Validierung.

## Basis-Setup

### 1. Schema definieren (Zod)
```typescript
import { z } from "zod"

export const userFormSchema = z.object({
  email: z.string().email("Ungültige E-Mail-Adresse"),
  name: z.string().min(2, "Name muss mindestens 2 Zeichen haben"),
  role: z.enum(["admin", "user"]),
  active: z.boolean().default(true),
})

// Typ ableiten
export type UserFormValues = z.infer<typeof userFormSchema>
```

### 2. Form erstellen
```typescript
"use client"

import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { userFormSchema, type UserFormValues } from "./schema"

export function UserForm() {
  const form = useForm<UserFormValues>({
    resolver: zodResolver(userFormSchema),
    defaultValues: {
      email: "",
      name: "",
      role: "user",
      active: true,
    },
  })

  async function onSubmit(data: UserFormValues) {
    // data ist typsicher und validiert
    await saveUser(data)
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* Fields hier */}
      </form>
    </Form>
  )
}
```

---

## ShadCN Form Components

### FormField Pattern
```tsx
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form"
import { Input } from "@/components/ui/input"

<FormField
  control={form.control}
  name="email"
  render={({ field }) => (
    <FormItem>
      <FormLabel>E-Mail</FormLabel>
      <FormControl>
        <Input placeholder="name@example.com" {...field} />
      </FormControl>
      <FormDescription>
        Deine geschäftliche E-Mail-Adresse.
      </FormDescription>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Select Field
```tsx
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"

<FormField
  control={form.control}
  name="role"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Rolle</FormLabel>
      <Select onValueChange={field.onChange} defaultValue={field.value}>
        <FormControl>
          <SelectTrigger>
            <SelectValue placeholder="Rolle wählen" />
          </SelectTrigger>
        </FormControl>
        <SelectContent>
          <SelectItem value="admin">Admin</SelectItem>
          <SelectItem value="user">User</SelectItem>
        </SelectContent>
      </Select>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Checkbox Field
```tsx
import { Checkbox } from "@/components/ui/checkbox"

<FormField
  control={form.control}
  name="active"
  render={({ field }) => (
    <FormItem className="flex flex-row items-start space-x-3 space-y-0">
      <FormControl>
        <Checkbox
          checked={field.value}
          onCheckedChange={field.onChange}
        />
      </FormControl>
      <div className="space-y-1 leading-none">
        <FormLabel>Aktiv</FormLabel>
        <FormDescription>
          Benutzer kann sich einloggen.
        </FormDescription>
      </div>
    </FormItem>
  )}
/>
```

---

## Zod Schema Patterns

### Optionale Felder
```typescript
const schema = z.object({
  required: z.string().min(1, "Pflichtfeld"),
  optional: z.string().optional(),
  nullableOptional: z.string().nullable().optional(),
})
```

### Conditional Validation
```typescript
const schema = z.object({
  type: z.enum(["individual", "company"]),
  companyName: z.string().optional(),
}).refine(
  (data) => data.type !== "company" || data.companyName,
  {
    message: "Firmenname ist bei Unternehmen Pflicht",
    path: ["companyName"],
  }
)
```

### Transform & Preprocess
```typescript
const schema = z.object({
  // Trimmen vor Validierung
  email: z.string().trim().email(),
  
  // String zu Zahl
  age: z.string().transform((val) => parseInt(val, 10)),
  
  // Leerer String zu undefined
  optional: z.string().transform((val) => val || undefined).optional(),
})
```

### Custom Validation
```typescript
const passwordSchema = z.string()
  .min(8, "Mindestens 8 Zeichen")
  .regex(/[A-Z]/, "Mindestens ein Großbuchstabe")
  .regex(/[0-9]/, "Mindestens eine Zahl")
```

---

## Async Validation

### Server-seitige Prüfung
```typescript
const schema = z.object({
  username: z.string().min(3),
})

// In der Komponente
async function onSubmit(data: FormValues) {
  // Prüfe ob Username verfügbar
  const exists = await checkUsernameExists(data.username)
  if (exists) {
    form.setError("username", { 
      message: "Username bereits vergeben" 
    })
    return
  }
  // Weiter mit Submit
}
```

---

## Form States

### Loading State
```tsx
const { formState: { isSubmitting } } = form

<Button type="submit" disabled={isSubmitting}>
  {isSubmitting ? "Speichert..." : "Speichern"}
</Button>
```

### Error Handling
```tsx
async function onSubmit(data: FormValues) {
  try {
    await saveData(data)
    toast.success("Gespeichert!")
  } catch (error) {
    toast.error("Fehler beim Speichern")
    // Oder spezifischen Feld-Fehler setzen
    form.setError("root", { message: "Server-Fehler" })
  }
}
```

### Reset Form
```tsx
// Nach erfolgreichem Submit
form.reset()

// Mit neuen Werten
form.reset({ email: "new@example.com" })
```

---

## Best Practices

### 1. Schema in separater Datei
```
components/
  user-form/
    schema.ts      # Zod Schema + Types
    user-form.tsx  # React Component
    index.ts       # Export
```

### 2. Wiederverwendbare Schemas
```typescript
// src/lib/schemas/common.ts
export const emailSchema = z.string().email()
export const uuidSchema = z.string().uuid()
export const dateSchema = z.string().datetime()
```

### 3. Form mit Default Values aus Props
```tsx
interface UserFormProps {
  user?: User  // Für Edit-Mode
  onSuccess: () => void
}

export function UserForm({ user, onSuccess }: UserFormProps) {
  const form = useForm<UserFormValues>({
    resolver: zodResolver(userFormSchema),
    defaultValues: user ?? {
      email: "",
      name: "",
    },
  })
}
```

---

## Checkliste

- [ ] Zod Schema definiert
- [ ] TypeScript Typ aus Schema abgeleitet (`z.infer`)
- [ ] `zodResolver` verwendet
- [ ] `defaultValues` gesetzt (verhindert uncontrolled→controlled Warnung)
- [ ] Alle Fields mit `FormField` + `FormControl` gewrappt
- [ ] `FormMessage` für Fehleranzeige
- [ ] Loading State während Submit
- [ ] Error Handling mit Toast oder `setError`
